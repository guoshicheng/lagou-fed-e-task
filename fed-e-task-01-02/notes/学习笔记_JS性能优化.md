# JS 性能优化

### 内存管理

人为操作空间，① 申请 ② 使用 ③ 释放

### 垃圾回收与常见 GC 算法

内存角度：从**根**上无法访问，或不能在被引用的对象。
程序角度：不能再访问的对象，不再需要。
GC 算法：垃圾回收机制是通过什么算法进行工作的

1. 引用计数法：判断引用数，为 0 即为垃圾，进行回收。引用关系变化会出发计数器加一减一的操作。  
   优点：立即回收，避免造成程序卡顿。缺点：时间开销大，无法解决循环引用的问题。
2. 标记清除算法：从根上遍历可达对象，标记为活动对象，然后清除没有标记的对象。  
   优点：解决了循环引用的问题。 缺点：造成内存碎片化。
3. 标记整理算法：再标记清除算法的基础上，清除对象之前，对内存进行整理，然后再清楚对象回收内存。  
   优点：避免了内存碎片化。缺点：因为要整理移动对象，所以效率低。

### V8 引擎的垃圾回收策略

采用分代回收思想，分为新生代对象和老生代对象。针对不同对象采用不同算法。

**新生代对象**使用空间复制算法和标记整理算法，空间分为两部分，From 使用空间和 To 空闲空间。  
当 From 空间内存不足时，先利用标记整理，然后将活动对象拷贝到 To 空间，最后释放 From 空间内存。

**老生代对象**使用标记清除、标记整理和增量标记算法。

1. 先使用标记清除算法，担忧碎片。
2. 当有新生代对象晋升为老生代对象时，空间不够就触发标记整理。
3. 增量标记算法，让标记可达对象的过程分段进行，避免程序执行暂停，提高效率。

### Performace 工具

问题：页面延迟，卡顿。原因：频繁的垃圾回收，用过内存变化图分析。  
问题：页面早高性能。原因：内存膨胀。需要判定问题，在多个设备运行。  
问题：页面随时间越来越慢。原因：内存泄漏，内存持续升高。  
监控方式：

1. 浏览其任务管理器
2. timeline 时序图
3. 堆快照查找分离 DOM

### 代码优化

1. 慎用全局变量  
   原因：查找费资源；费内存；容易污染全局。
2. 缓存全局变量到局部变量。
3. 通过原型链新增方法，不要放在构造函数内部。
4. 避免闭包陷阱  
   容易出现内存泄漏，所以最好主动释放变量。
5. 避免属性访问方法，getXXX()
6. 优化 for 循环，for(let i = 0, len = x.length;i < len; i++)  
   效率： foreach() > for() > for ... in ...
7. 文档碎片优化
8. 克隆节点优化
9. 直接量优化
   var arr = [1,2,3]
