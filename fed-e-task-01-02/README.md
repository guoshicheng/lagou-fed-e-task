# fed-e-task-01-02

# 模块二：ES 新特性与 TypeScript、JS 性能优化

## 简答题

### 一、请说出下列最终的执行结果，并解释为什么。

```javascript
var a = [];

for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();
```

答: 运行结果为 10。 var i 为全局变量。当 for 循环结束，i 的值为 10，所以在 a[6] 执行时将打印 10。

### 二、请说出下列最终的执行结果，并解释为什么。

```javascript
var tmp = 123;

if (true) {
  console.log(tmp);
  let tmp;
}
```

答: 代码第四行为“暂时性死区”，所以执行结果报出 ReferenceError。  
第一，如果在块级作用域中包含 let 声明，那么这个声明的变量就不再受外部的影响。例如 if 语句中的 tmp 就不受父级作用域的影响。  
第二，let 声明的变量在声明之前不可以使用。  
这两点就形成了“暂时性死区”，在这个块级作用域中，声明之前使用变量，运行时就会报错。

### 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值。

```javascript
var arr = [12, 34, 32, 89, 4];
var min = arr.reduce((x, y) => (x < y ? x : y));
```

### 四、请详细说明 var，let, const 三种声明变量的方式之间的具体差别。

答: var 如果声明在函数里为局部变量，声明在函数外则为全局变量。  
var 存在变量提升，变量可以在声明之前使用， 值为 undefined。  
var 可以重复声明。

let 声明的变量只在声明所在的代码块中有效。  
let 声明的变量不能再声明之前使用，否则报错。  
let 不可以重复声明。

const 的作用是声明常量，一旦初始化便不能改变。如果声明的是对象，那指针不会变，但对象的属性可以改变。其他与 let 一致。

### 五、请说出下列代码最终输出的结果，并解释为什么。

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};
obj.fn();
```

答: 输出结果为 20，因为 fn()由对象 obj 调用，所以 this 指向 obj，那 this.a 就是 obj 的属性 a，值为 20。

### 六、简述 Symbol 类型的用途。

答：Symbol 是原始数据类型，可以获取一个独一无二的值.  
一、它可以用来给对象设置独一无二的属性名，避免与其他属性名冲突或覆盖。  
二、还可以用 Symbol 创建对象的内部属性，这些内部属性不会被常规方法遍历到。例如：Object.keys()和 JSON.stringify()。但不包括 Object.getOwnPropertySymbols()和 Reflect.ownKeys()。
三、Symbol 还内置了一些常量，可以让自定义对象实现一些内置接口。

### 七、说说什么是浅拷贝，什么是深拷贝？

答：对于引用数据类型，例如一个对象，浅拷贝会新建一个对象，然后复制源对象在堆内存中的数据。所以修改新建对象的属性值不会影响源对象。  
但如果这个属性值是一个引用数据类型，那么修改这个引用数据类型的内容，就会影响到源对象。  
换句话说，浅拷贝只复制第一层数据，第二层数据不复制，修改第二层数据依旧影响原来的数据。  
而深拷贝则是不管第几层数据，全部拷贝。所以怎么修改新对象，源对象都不会受影响。

### 八、请简述 TypeScript 与 JavaScript 之间的关系。

TypeScript 是 JavaScript 的超集，TypeScript 可以运行 JavaScript 代码。  
TypeScript 在 JavaScript 的基础上增加了数据类型检测。  
TypeScript 运行前需要编译成 JavaScript。

### 九、请谈谈你所认为的 TypeScript 优缺点。

优点：因为 TypeScript 的类型系统，代码在运行之前就可以发现一些错误。
在编写时也有代码提示。  
缺点：代码量变多，要写很多类型定义，这增加了开发成本。

### 十、描述引用计数的工作原理和优缺点。

工作原理：为每一个对象设置一个计数器，初始值为 0，当这个对象被其他对象引用时，计数器加一。如果删除了对这个对象的引用，那么计数器减一。当计数器为 0 时，这个对象就会被回收。

优点：随时进行垃圾回收，不会造成程序的卡顿。  
缺点：无法处理循环引用的情况，造成内存泄漏。

### 十一、描述标记整理算法的工作流程。

1. 遍历所有可以访问到的对象，并标记为可达对象。
2. 内存不足时，遍历堆中的所有对象，将所有可达对象向一端以动。
3. 将最后一个可达对象之后的内存全部清除。

### 十二、描述 V8 中新生代存储区垃圾回收的流程。

1. 新生代存储区被分为了两个区域，使用空间 From 和空闲空间 To.
2. 当 From 空间内存不足就对其执行标记整理算法。
3. 将所有可达对象拷贝到 To 空间，部分新生代对象晋升到老生代空间。
4. 释放 From 空间 完成 From 和 To 空间交换。

### 十三、描述增量标记算法在何时使用及工作原理。

答：在老生代空间进行垃圾回收时使用。  
工作原理：程序不需要等到垃圾回收完全结束才能重新开始运行，在垃圾回收的过程中控制权可以临时交还给运行时进行一定的操作。
